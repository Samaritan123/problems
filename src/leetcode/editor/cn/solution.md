### P4 寻找两个正序数组的中位数

#### 题意

给两个从小到大排序的数组，求这两个数组合并之后的中位数，要求时间复杂度为log

#### Tags

二分

#### 题解

问题可以转化为求这两个数组的第k大数，采用二分的方法，取出A数组第k/2位置的数a和B数组第k/2位置的数b，如果a<=b，容易证明A[1] - A[k/2]这些数必然排在合并之后数组的前k-1个，这样就可以砍去这些数，在剩下的数里面寻找第k-k/2大的数，b>a同理，k最多被分log次，k为1之后可以直接找到所需要的数。

#### Tips

还有一些细节需要处理，比如k/2超过了目前正在处理的数组的长度，这样就直接取数组的末尾



### P41 缺失的第一个正数

#### 题意

给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。要求时间复杂度O(n)，只能使用常数级别的额外空间

#### Tags

数组，思维

#### 题解

长度为n的数组答案最大为n+1，如果没有空间的要求的话，最简单的方法就是开一个长为n+1的标记数组，标记值在1-n之间且出现过的数，最后扫描一遍标记数组就可以得到答案，这样会使用O(n)级别的额外空间。

解决方法就是复用原有的数组，可以把原有的数组当作标记数组来使用，可是还要保证数组不能丢失原有的信息。显然超过n的数具体数值是多少可以不用关心，不会影响最终的结果，可以先扫描一遍把它们都设为0。然后打标记的时候，直接将对应位置的值减去n+1，这样如果一个位置的值为负数，我们就知道这个位置已经被标记过，而且只要加上n+1就能还原这个位置原本的数字。最后再遍历一遍数组，找到第一个值为正数的下标即可。

#### Tips

核心思路是如何在不丢失原有信息的情况下复用数组，方法就是减掉一个合适的定值，这类题通常都是这种解决方案



### P42 接雨水

#### 题意

n*m的矩阵，每个位置从下到上放着一定数量的正方体，问下雨天最多能存多少格子的雨水

#### Tags

堆

#### 题解

显然四周的是不可能储水的，他们的最终高度是确定的就是原本的高度。用一个小根堆来维护所有已经确定好了最终高度的格子（最终高度最小的在堆顶），先把四周的格子扔到小根堆里，每次取出堆顶的格子p，遍利它上下左右四个方位的格子，如果某个格子q没有被访问过，则标记访问，q的最终高度为p的最终高度和q的初始高度的较小值，确定了q的最终高度后再把q扔进堆里，这样一直循环重复直到所有格子都被访问过。

#### Tips

因为每次取出的都是最终高度最小的格子，这样它一定可以决定四周格子的最终高度，因为没有比它更矮的了



### P381 O(1) 时间插入、删除和获取随机元素 - 允许重复

#### 题意

![image-20201220105529327](C:\Users\Administrator\Desktop\note\solution.assets\image-20201220105529327.png)

#### Tags

设计

#### 题解

题意就是要设计一个可重复元素的集合，允许插入、删除、随机返回一个元素。

如果可以维护一个0 - n-1（n是集合元素的个数）的一个list存储集合中的所有元素（位置我们并不关心），这样每次取随机数直接生成1个0-（n-1)的下标即可。维护一个Map<Integer,Set\<Integer>> map，key是元素值，value是该值对应在list中的下标集合。

先看insert，insert非常简单，直接往List末尾add就行了，list有效长度加1，更新map。

remove稍微复杂一些，首先需要找到remove的元素对应在list中的任意一个位置，这个直接从map里面拿，找到一个位置后，将list末尾的数移到此位置，然后list有效长度减一（通过这种方式就相当于巧妙的删除了这个数，同时保持了list在有效长度区域内的连贯性)，更新map。

#### Tips

相到用list来维护集合就比较容易了



### P432 全 O(1) 的数据结构

#### 题意

![image-20201220104213241](C:\Users\Administrator\Desktop\note\solution.assets\image-20201220104213241.png)

要求所有操作时间复杂度O(1)

#### Tags

设计

#### 题解

HashMap+双向链表。双向链表每个node保存出现的次数和该次数所有对应的key的set，双向链表按出现次数从小到大连接在一起。map的值为key，value为node，每次操作维护map和双向链表即可。

#### Tips

无



### P446 等差数列划分 II - 子序列

#### 题意

长度为n的序列（n<=1000)，求其中是等差数列的子序列个数（子序列长度至少为3）

#### Tags

动态规划

#### 题解

先把问题转化一下，允许等差数列长度为2，最后再把个数减去C(n,2)即可。dp\[i]\[j\]表示最后两个数分别为i和j的满足是等差数列的子序列个数（注意这里的i、j是数值不是下标）。遍历数组不断将数字添加到新序列的末尾，然后更新dp数组的值。比如当前从新序列末尾又新增了一个数字q，则需要枚举前面已经出现过的所有的数值p，      f\[p][q]+=f\[2*p-q\]\[p]。数值可能很大，需要用hashMap代替dp数组或者离散化。

#### Tips

用数值去表示状态而不是用下标



